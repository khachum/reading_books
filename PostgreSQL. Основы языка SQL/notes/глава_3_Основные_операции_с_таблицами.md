# Основные операции с таблицами

Сегодня мы поиграемся с нашей игрушечной базой данных, которую мы создали в прошлый раз. 

Для этого подключемся к ней при помощи `pgcli`:

```
pgcli -h localhost -p 5432 -U demouser -d games
```

или запустим `psql`:

```
docker exec -it postgress psql -U demouser -d games
```

## Создание таблицы:

### Описание таблицы
Для создания таблицы используется команда `CREATE TABLE`. 
Ее упрощенный синтаксис выглядит так:

```
CREATE TABLE имя-таблицы
(
    имя-поля тип-данных [ограничения-целостности],
    имя-поля тип-данных [ограничения-целостности],
    ...
    имя-поля тип-данных [ограничения-целостности],
    [ограничение-целостности],
    [первичный-ключ],
    [внешний-ключ]
);  
```

Если нужно посмотреть полный синтаксис, то можно ввести команду `\h CREATE TABLE`.

Нам надо ввести таблицу со следующей структурой:

| Описание атрибута                 | Имя атрибута   | Тип данных | Тип PostgreSQL | Ограничения        |
|-----------------------------------|----------------|------------|----------------|--------------------|
| Код самолета, IATA                | aircraft_code  | Символьный | char(3)        | NOT NULL           |
| Модель самолета                   | model          | Символьный | text           | NOT NULL           |
| Максимальная дальность полета, км | range          | Числовой   | integer        | NOT NULL range > 0 |

Типы:

**char** -- символьный тип, `char(n)` означает, что максимальное количество символов в этом поле `n`.

**text** -- символьный тип, но с потенциально бесконечным количеством символов

**integer** -- целочисленный

Ограничения:

**NOT NULL** -- означает, что у нас отсутствуют неопределенные значения

**range > 0** -- накладывает ограничения на то, что дальность полета не может быть отрицательной или нулевой.

В качестве **естественного** ключа выбран атрибут `Код самолета, IATA`. 
Это означает, что такое понятие есть и в предметной области, и в таблице есть такой атрибут. 
В других случаях используются **суррогатные** ключи.

### Создание таблицы

В консоли наша команда будет выглядеть следующим образом:

```
demouser@localhost:games> CREATE TABLE aircrafts 
 ( aircraft_code char(3) NOT NULL, 
   model text NOT NULL, 
   range integer NOT NULL,  
   CHECK(range > 0), 
   PRIMARY Key (aircraft_code) 
   ); 
                                                                                                                                                                                                     
CREATE TABLE
Time: 0.107s

```

Можем проверить, какую таблицу создала СУБД. Для этого служит команда `\d aircrafts`.

```
demouser@localhost:games> \d aircrafts                                                                                                                                                               
+---------------+--------------+-----------+
| Column        | Type         | Modifiers |
|---------------+--------------+-----------|
| aircraft_code | character(3) |  not null |
| model         | text         |  not null |
| range         | integer      |  not null |
+---------------+--------------+-----------+
Indexes:
    "aircrafts_pkey" PRIMARY KEY, btree (aircraft_code)
Check constraints:
    "aircrafts_range_check" CHECK (range > 0)

Time: 0.032s
```

Здесь интересно, что помимо таблицы созданы также **индексы** и **ограничения-проверки**. 

**Индекс** -- специальная структура данных, позволяющая решать задачу ускорения доступа 
к строкам в таблице, а также задачу предотвращения дублирования значений ключевых 
атрибутов в различных строках таблицы. Для реализации первичного ключа
(**PRIMARY KEY**) всегда автоматически создается индекс. Имя индекса в наше случае —
**aircrafts_pkey**. Оно было сгенерировано ядром PostgreSQL. Указан также и тип
индекса — **btree**, т. е. B-дерево. Далее в круглых скобках приводится список ключевых атрибутов. 
В нашем случае он состоит из одного атрибута — **aircraft_code**.

Далее в описании таблицы приводятся сведения об **ограничениях**, наложенных на
отдельные атрибуты таблицы и на таблицу в целом. В принципе, при создании 
таблицы можно задать свои собственные имена для всех ограничений, однако делать это
не обязательно. Мы не задавали никакого имени для ограничения, наложенного на основные 
операции с таблицами атрибут range, поэтому ядро PostgreSQL также сгенерировало это имя 
автоматически — **aircrafts_range_check**.

### Удаление таблицы

Тут все просто: 

```
DROP TABLE имя-таблицы;
```

### Ввод данных

Для ввода данных используется команда `INSERT`.
Ее упрощенный формат таков:
```
INSERT INTO имя-таблицы [( имя-атрибута, имя-атрибута, ... )]
    VALUES ( значение-атрибута, значение-атрибута, ... );

```

Давайте внесем данные в таблицу:

```
demouser@localhost:games> 
INSERT INTO aircrafts (aircraft_code, model, range)  
 VALUES ('SU9', 'Sukhoi SuperJet-100', 3000);                                                                                                                                                        
INSERT 0 1
Time: 0.085s
```
Мы могли бы вводить и без имен атрибутов, но тогда нам надо было бы держать в 
голове, порядок атрибутов при создании таблицы. Здесь же совсем не обязательно 
их перечислять в том порядке, в котором они идут в таблице. Главное, чтобы
атрибут и значение в команде соответствовали друг другу.

### SELECT

Для выборки информации из таблиц базы данных служит команда **SELECT**. 
Ее синтаксис, упрощенный до предела, таков:
```
SELECT имя-атрибута, имя-атрибута, ...
FROM имя-таблицы;
```
Если нам нужно вывести все атрибуты, то можем воспользоваться символом `*`.

Давайте вызовем эту команду для нашей таблицы:
```
demouser@localhost:games> SELECT * FROM aircrafts;                                                                                                                                                   
+---------------+---------------------+-------+
| aircraft_code | model               | range |
|---------------+---------------------+-------|
| SU9           | Sukhoi SuperJet-100 | 3000  |
+---------------+---------------------+-------+
SELECT 1
Time: 0.019s
```

Пока что ничего особенного. Давайте добавим еще несколько записей в таблицу:

```
demouser@localhost:games> INSERT INTO aircrafts ( aircraft_code, model, range ) 
 VALUES ( '773', 'Boeing 777-300', 11100 ), 
 ( '763', 'Boeing 767-300', 7900 ), 
 ( '733', 'Boeing 737-300', 4200 ), 
 ( '320', 'Airbus A320-200', 5700 ), 
 ( '321', 'Airbus A321-200', 5600 ), 
 ( '319', 'Airbus A319-100', 6700 ), 
 ( 'CN1', 'Cessna 208 Caravan', 1200 ), 
 ( 'CR2', 'Bombardier CRJ-200', 2700 );                                                                                                                                                              
INSERT 0 8
Time: 0.073s

```

Давайте снова посмотрим, что содержится в таблице «Самолеты»:

```
demouser@localhost:games> SELECT * FROM aircrafts;                                                                                                                                                   
+---------------+---------------------+-------+
| aircraft_code | model               | range |
|---------------+---------------------+-------|
| SU9           | Sukhoi SuperJet-100 | 3000  |
| 773           | Boeing 777-300      | 11100 |
| 763           | Boeing 767-300      | 7900  |
| 733           | Boeing 737-300      | 4200  |
| 320           | Airbus A320-200     | 5700  |
| 321           | Airbus A321-200     | 5600  |
| 319           | Airbus A319-100     | 6700  |
| CN1           | Cessna 208 Caravan  | 1200  |
| CR2           | Bombardier CRJ-200  | 2700  |
+---------------+---------------------+-------+
SELECT 9
Time: 0.019s
```

При выполнении простой выборки из таблицы СУБД не гарантирует
никакого конкретного порядка вывода строк. Если же вы хотите каким-то образом
упорядочить расположение выводимых строк, то необходимо предпринять 
дополнительные меры, а именно: использовать предложение **ORDER BY** команды **SELECT**.

Например:

```
demouser@localhost:games> SELECT model, aircraft_code, range 
 FROM aircrafts 
 ORDER BY model;                                                                                                                                                                                     
+---------------------+---------------+-------+
| model               | aircraft_code | range |
|---------------------+---------------+-------|
| Airbus A319-100     | 319           | 6700  |
| Airbus A320-200     | 320           | 5700  |
| Airbus A321-200     | 321           | 5600  |
| Boeing 737-300      | 733           | 4200  |
| Boeing 767-300      | 763           | 7900  |
| Boeing 777-300      | 773           | 11100 |
| Bombardier CRJ-200  | CR2           | 2700  |
| Cessna 208 Caravan  | CN1           | 1200  |
| Sukhoi SuperJet-100 | SU9           | 3000  |
+---------------------+---------------+-------+
SELECT 9
Time: 0.021s

```

Как мы видим, здесь мы отсортировали по имени модели.
Попробуем отсортировать по атрибуту **range**:

```
demouser@localhost:games> SELECT model, aircraft_code, range 
 FROM aircrafts 
 ORDER BY range;                                                                                                                                                                                     
+---------------------+---------------+-------+
| model               | aircraft_code | range |
|---------------------+---------------+-------|
| Cessna 208 Caravan  | CN1           | 1200  |
| Bombardier CRJ-200  | CR2           | 2700  |
| Sukhoi SuperJet-100 | SU9           | 3000  |
| Boeing 737-300      | 733           | 4200  |
| Airbus A321-200     | 321           | 5600  |
| Airbus A320-200     | 320           | 5700  |
| Airbus A319-100     | 319           | 6700  |
| Boeing 767-300      | 763           | 7900  |
| Boeing 777-300      | 773           | 11100 |
+---------------------+---------------+-------+
SELECT 9
Time: 0.026s

```

